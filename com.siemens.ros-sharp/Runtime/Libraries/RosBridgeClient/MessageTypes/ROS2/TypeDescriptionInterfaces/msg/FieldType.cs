/* 
 * This message is auto generated by ROS#. Please DO NOT modify.
 * Note:
 * - Comments from the original code will be written in their own line 
 * - Variable sized arrays will be initialized to array of size 0 
 * Please report any issues at 
 * <https://github.com/siemens/ros-sharp> 
 */

#if ROS2

namespace RosSharp.RosBridgeClient.MessageTypes.TypeDescriptionInterfaces
{
    public class FieldType : Message
    {
        public const string RosMessageName = "type_description_interfaces/msg/FieldType";

        //  Represents the type of a field and related meta-data.
        //  A constant for each type supported according to:
        //    http://design.ros2.org/articles/legacy_interface_definition.html
        //  and:
        //    http://design.ros2.org/articles/idl_interface_definition.html
        //  Order is loosely coupled to the order of appearance in the IDL 4.2 spec:
        //   https://www.omg.org/spec/IDL/4.2
        //  Layout of constants across the 0-255 decimal values in the uint8:
        // 
        //  - 000    : Reserved for "not set"
        //  - 001-048: Primitive types, strings, and reserved space for future primitive types
        //  - 049-096: Fixed sized array of primitive and string types
        //  - 097-144: Bounded Sequences of primitive and string types
        //  - 145-192: Unbounded Sequences of primitive and string types
        //  - 193-255: Reserved space for future array/sequence-like types
        public const byte FIELD_TYPE_NOT_SET = 0;
        //  Nested type defined in other .msg/.idl files.
        public const byte FIELD_TYPE_NESTED_TYPE = 1;
        //  Integer Types
        public const byte FIELD_TYPE_INT8 = 2;
        public const byte FIELD_TYPE_UINT8 = 3;
        public const byte FIELD_TYPE_INT16 = 4;
        public const byte FIELD_TYPE_UINT16 = 5;
        public const byte FIELD_TYPE_INT32 = 6;
        public const byte FIELD_TYPE_UINT32 = 7;
        public const byte FIELD_TYPE_INT64 = 8;
        public const byte FIELD_TYPE_UINT64 = 9;
        //  Floating-Point Types
        public const byte FIELD_TYPE_FLOAT = 10;
        public const byte FIELD_TYPE_DOUBLE = 11;
        public const byte FIELD_TYPE_LONG_DOUBLE = 12;
        //  Char and WChar Types
        public const byte FIELD_TYPE_CHAR = 13;
        public const byte FIELD_TYPE_WCHAR = 14;
        //  Boolean Type
        public const byte FIELD_TYPE_BOOLEAN = 15;
        //  Byte/Octet Type
        public const byte FIELD_TYPE_BYTE = 16;
        //  String Types
        public const byte FIELD_TYPE_STRING = 17;
        public const byte FIELD_TYPE_WSTRING = 18;
        //  Fixed String Types
        public const byte FIELD_TYPE_FIXED_STRING = 19;
        public const byte FIELD_TYPE_FIXED_WSTRING = 20;
        //  Bounded String Types
        public const byte FIELD_TYPE_BOUNDED_STRING = 21;
        public const byte FIELD_TYPE_BOUNDED_WSTRING = 22;
        //  Fixed Sized Array Types
        public const byte FIELD_TYPE_NESTED_TYPE_ARRAY = 49;
        public const byte FIELD_TYPE_INT8_ARRAY = 50;
        public const byte FIELD_TYPE_UINT8_ARRAY = 51;
        public const byte FIELD_TYPE_INT16_ARRAY = 52;
        public const byte FIELD_TYPE_UINT16_ARRAY = 53;
        public const byte FIELD_TYPE_INT32_ARRAY = 54;
        public const byte FIELD_TYPE_UINT32_ARRAY = 55;
        public const byte FIELD_TYPE_INT64_ARRAY = 56;
        public const byte FIELD_TYPE_UINT64_ARRAY = 57;
        public const byte FIELD_TYPE_FLOAT_ARRAY = 58;
        public const byte FIELD_TYPE_DOUBLE_ARRAY = 59;
        public const byte FIELD_TYPE_LONG_DOUBLE_ARRAY = 60;
        public const byte FIELD_TYPE_CHAR_ARRAY = 61;
        public const byte FIELD_TYPE_WCHAR_ARRAY = 62;
        public const byte FIELD_TYPE_BOOLEAN_ARRAY = 63;
        public const byte FIELD_TYPE_BYTE_ARRAY = 64;
        public const byte FIELD_TYPE_STRING_ARRAY = 65;
        public const byte FIELD_TYPE_WSTRING_ARRAY = 66;
        public const byte FIELD_TYPE_FIXED_STRING_ARRAY = 67;
        public const byte FIELD_TYPE_FIXED_WSTRING_ARRAY = 68;
        public const byte FIELD_TYPE_BOUNDED_STRING_ARRAY = 69;
        public const byte FIELD_TYPE_BOUNDED_WSTRING_ARRAY = 70;
        //  Bounded Sequence Types
        public const byte FIELD_TYPE_NESTED_TYPE_BOUNDED_SEQUENCE = 97;
        public const byte FIELD_TYPE_INT8_BOUNDED_SEQUENCE = 98;
        public const byte FIELD_TYPE_UINT8_BOUNDED_SEQUENCE = 99;
        public const byte FIELD_TYPE_INT16_BOUNDED_SEQUENCE = 100;
        public const byte FIELD_TYPE_UINT16_BOUNDED_SEQUENCE = 101;
        public const byte FIELD_TYPE_INT32_BOUNDED_SEQUENCE = 102;
        public const byte FIELD_TYPE_UINT32_BOUNDED_SEQUENCE = 103;
        public const byte FIELD_TYPE_INT64_BOUNDED_SEQUENCE = 104;
        public const byte FIELD_TYPE_UINT64_BOUNDED_SEQUENCE = 105;
        public const byte FIELD_TYPE_FLOAT_BOUNDED_SEQUENCE = 106;
        public const byte FIELD_TYPE_DOUBLE_BOUNDED_SEQUENCE = 107;
        public const byte FIELD_TYPE_LONG_DOUBLE_BOUNDED_SEQUENCE = 108;
        public const byte FIELD_TYPE_CHAR_BOUNDED_SEQUENCE = 109;
        public const byte FIELD_TYPE_WCHAR_BOUNDED_SEQUENCE = 110;
        public const byte FIELD_TYPE_BOOLEAN_BOUNDED_SEQUENCE = 111;
        public const byte FIELD_TYPE_BYTE_BOUNDED_SEQUENCE = 112;
        public const byte FIELD_TYPE_STRING_BOUNDED_SEQUENCE = 113;
        public const byte FIELD_TYPE_WSTRING_BOUNDED_SEQUENCE = 114;
        public const byte FIELD_TYPE_FIXED_STRING_BOUNDED_SEQUENCE = 115;
        public const byte FIELD_TYPE_FIXED_WSTRING_BOUNDED_SEQUENCE = 116;
        public const byte FIELD_TYPE_BOUNDED_STRING_BOUNDED_SEQUENCE = 117;
        public const byte FIELD_TYPE_BOUNDED_WSTRING_BOUNDED_SEQUENCE = 118;
        //  Unbounded Sequence Types
        public const byte FIELD_TYPE_NESTED_TYPE_UNBOUNDED_SEQUENCE = 145;
        public const byte FIELD_TYPE_INT8_UNBOUNDED_SEQUENCE = 146;
        public const byte FIELD_TYPE_UINT8_UNBOUNDED_SEQUENCE = 147;
        public const byte FIELD_TYPE_INT16_UNBOUNDED_SEQUENCE = 148;
        public const byte FIELD_TYPE_UINT16_UNBOUNDED_SEQUENCE = 149;
        public const byte FIELD_TYPE_INT32_UNBOUNDED_SEQUENCE = 150;
        public const byte FIELD_TYPE_UINT32_UNBOUNDED_SEQUENCE = 151;
        public const byte FIELD_TYPE_INT64_UNBOUNDED_SEQUENCE = 152;
        public const byte FIELD_TYPE_UINT64_UNBOUNDED_SEQUENCE = 153;
        public const byte FIELD_TYPE_FLOAT_UNBOUNDED_SEQUENCE = 154;
        public const byte FIELD_TYPE_DOUBLE_UNBOUNDED_SEQUENCE = 155;
        public const byte FIELD_TYPE_LONG_DOUBLE_UNBOUNDED_SEQUENCE = 156;
        public const byte FIELD_TYPE_CHAR_UNBOUNDED_SEQUENCE = 157;
        public const byte FIELD_TYPE_WCHAR_UNBOUNDED_SEQUENCE = 158;
        public const byte FIELD_TYPE_BOOLEAN_UNBOUNDED_SEQUENCE = 159;
        public const byte FIELD_TYPE_BYTE_UNBOUNDED_SEQUENCE = 160;
        public const byte FIELD_TYPE_STRING_UNBOUNDED_SEQUENCE = 161;
        public const byte FIELD_TYPE_WSTRING_UNBOUNDED_SEQUENCE = 162;
        public const byte FIELD_TYPE_FIXED_STRING_UNBOUNDED_SEQUENCE = 163;
        public const byte FIELD_TYPE_FIXED_WSTRING_UNBOUNDED_SEQUENCE = 164;
        public const byte FIELD_TYPE_BOUNDED_STRING_UNBOUNDED_SEQUENCE = 165;
        public const byte FIELD_TYPE_BOUNDED_WSTRING_UNBOUNDED_SEQUENCE = 166;
        //  Identifying number for the type of the field, using one of the above constants.
        public byte type_id { get; set; } = 0;

        //  Only used when the type is an array or a bounded sequence.
        //  In the case of an array, this is the fixed capacity of the array.
        //  In the case of a bounded sequence, this is the maximum capacity of the sequence.
        //  In all other cases this field is unused.
        public ulong capacity { get; set; }
        //  Only used when the type is a fixed or bounded string/wstring, or a array/sequence of those.
        //  In the case of a fixed string/wstring, it is the fixed length of the string.
        //  In the case of a bounded string/wstring, it is the maximum capacity of the string.
        //  In the case of an array/sequence of fixed string/wstring, it is the fixed length of the strings.
        //  In the case of an array/sequence of bounded string/wstring, it is the maximum capacity of the strings.
        //  It is not currently possible to have different string capacities per element in the array/sequence.
        public ulong string_capacity { get; set; }
        //  Only used when the type is a nested type or array/sequence of nested types.
        //  This is limited to 255 characters.
        //  TODO(wjwwood): this 255 character limit was chosen due to this being the limit
        //    for DDSI-RTPS based middlewares, which is the most commonly used right now.
        //    We lack a ROS 2 specific limit in our design documents, but we should update
        //    this and/or link to the design doc when that is available.
        public string nested_type_name { get; set; }

        public FieldType()
        {
            this.capacity = 0;
            this.string_capacity = 0;
            this.nested_type_name = "";
        }

        public FieldType(ulong capacity, ulong string_capacity, string nested_type_name, byte type_id = 0)
        {
            this.type_id = type_id;
            this.capacity = capacity;
            this.string_capacity = string_capacity;
            this.nested_type_name = nested_type_name;
        }
    }
}
#endif
