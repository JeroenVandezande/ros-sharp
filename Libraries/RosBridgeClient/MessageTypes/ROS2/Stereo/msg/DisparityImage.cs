/* 
 * This message is auto generated by ROS#. Please DO NOT modify.
 * Note:
 * - Comments from the original code will be written in their own line 
 * - Variable sized arrays will be initialized to array of size 0 
 * Please report any issues at 
 * <https://github.com/siemens/ros-sharp> 
 */

#if ROS2

using RosSharp.RosBridgeClient.MessageTypes.Std;
using RosSharp.RosBridgeClient.MessageTypes.Sensor;

namespace RosSharp.RosBridgeClient.MessageTypes.Stereo
{
    public class DisparityImage : Message
    {
        public const string RosMessageName = "stereo_msgs/msg/DisparityImage";

        //  Separate header for compatibility with current TimeSynchronizer.
        //  Likely to be removed in a later release, use image.header instead.
        public Header header { get; set; }
        //  Floating point disparity image. The disparities are pre-adjusted for any
        //  x-offset between the principal points of the two cameras (in the case
        //  that they are verged). That is: d = x_l - x_r - (cx_l - cx_r)
        public Image image { get; set; }
        //  Stereo geometry. For disparity d, the depth from the camera is Z = fT/d.
        public float f { get; set; }
        //  Focal length, pixels
        public float t { get; set; }
        //  Baseline, world units
        //  Subwindow of (potentially) valid disparity values.
        public RegionOfInterest valid_window { get; set; }
        //  The range of disparities searched.
        //  In the disparity image, any disparity less than min_disparity is invalid.
        //  The disparity search range defines the horopter, or 3D volume that the
        //  stereo algorithm can "see". Points with Z outside of:
        //      Z_min = fT / max_disparity
        //      Z_max = fT / min_disparity
        //  could not be found.
        public float min_disparity { get; set; }
        public float max_disparity { get; set; }
        //  Smallest allowed disparity increment. The smallest achievable depth range
        //  resolution is delta_Z = (Z^2/fT)*delta_d.
        public float delta_d { get; set; }

        public DisparityImage()
        {
            this.header = new Header();
            this.image = new Image();
            this.f = 0.0f;
            this.t = 0.0f;
            this.valid_window = new RegionOfInterest();
            this.min_disparity = 0.0f;
            this.max_disparity = 0.0f;
            this.delta_d = 0.0f;
        }

        public DisparityImage(Header header, Image image, float f, float t, RegionOfInterest valid_window, float min_disparity, float max_disparity, float delta_d)
        {
            this.header = header;
            this.image = image;
            this.f = f;
            this.t = t;
            this.valid_window = valid_window;
            this.min_disparity = min_disparity;
            this.max_disparity = max_disparity;
            this.delta_d = delta_d;
        }
    }
}
#endif
